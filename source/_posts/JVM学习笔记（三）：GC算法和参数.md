---
title: JVM学习笔记（三）：GC算法，垃圾收集器种类及GC参数
date: 2018-5-9 18:26:56 
tags: JVM
categories: Java基础

---
## 0.学习准备
1. 基础落下了很多了，是时候啃一波JVM了
感觉很深奥，就先从视频看起，以后再看书补充啦
2. 参考资料
参考书籍《深入理解Java虚拟机》
第三章：垃圾收集器与内存分配策略
参考视频《深入理解JVM》(目前学习)
3. 简单目录：
	- GC简介
	- GC算法
		- 引用计数法
		- 标记清除算法
		- 标记压缩算法(标记整理)
		- 复制算法(新生代整合)
		- 分代思想
	- 可触及性(可达性)
	- Stop-The-World

---
## 1.GC的概念
1. GC:Garbage Collection，垃圾收集
C语言是程序员自己申请和释放(管理)空间，Java中则是虚拟机来实现
(垃圾是指程序运行过程中产生的一些无用的对象，这些对象仍然占据了一定的内存空间，无用的对象需要及时回收以确保程序有足够的空间)
2. Java中，GC的对象是堆空间和永久区(受GC管理)。
JVM中有单独一个线程根据特定的算法来监控，扫描，释放无用的对象。
最主要的目的是为了防止程序员的操作而导致的内存泄露。
3. GC的思想最早出现在1960年时的List语言。
4. GC如何去管理内存空间--**GC算法**

---
## 2.引用计数法
**1)引用计数法简介：**
1. 老牌的垃圾回收算法：
给对象添加一个计数器，非0可用，0不可用。(差不多就是这种原理)
2. 通过引用计算来进行垃圾回收。
实现简单，判定效率也高，大部分情况下是一种不错的算法。
(不过在JVM中不常用)
3. 在以下技术中都有应用案例：
	- 微软的COM
	- ActionScript3的FlashPlayer
	- Python

**2)引用计数法的执行过程：**
1. 对于一个对象A，只要有任何一个对象去引用了A，则A的引用计数器就会加1，引用失效时A的引用数器就会减1，只要一个对象的程序计数器为0则该对象就不可用了(死了)。
2. 引用计数法的简单回收过程：(虚线代表引用失效)
![](http://p5ki4lhmo.bkt.clouddn.com/00060JVM%E5%AD%A6%E4%B9%A03-01.jpg)

**3)引用计数法的问题：**
1. 引用计数法的问题：
	- 引用和区引用都伴随着加减，影响性能
	- 很难处理循环引用
2. 循环引用的简单示意图：
![](http://p5ki4lhmo.bkt.clouddn.com/00060JVM%E5%AD%A6%E4%B9%A03-02.jpg)
3. 使用引用计数法处理循环引用的过程：
![](http://p5ki4lhmo.bkt.clouddn.com/00060JVM%E5%AD%A6%E4%B9%A03-03.jpg)
三个循环引用的对象对根对象来说不可达（应该被回收），但是因为每个对象的引用计数器都是1，所以都不会被回收。

---
## 3.标记-清除算法与标记-压缩算法
**1)标记清除算法：**
1. 标记清除算法是现代垃圾回收算法的思想基础。
分为两阶段：标记阶段和清除阶段。
2. 一种可行的实现：
	- 标记阶段：从根节点开始标记所以从根节点开始的可达对象。未被标记的对象则视为垃圾对象。
	- 清除阶段：清除所有的未被标记的对象。
3. 标记清除算法的示意图：
![](http://p5ki4lhmo.bkt.clouddn.com/00060JVM%E5%AD%A6%E4%B9%A03-04.jpg)
4. 标记-清除算法的不足之处：
	- 效率问题：标记和清除过程的效率都不高
	- 空间问题：清除之后产生大量不连续的内存碎片

**2)标记压缩算法(标记整理算法)：**
1. 标记压缩算法适用于存活对象较多的场合，如老年代。
是对标记清除算法的优化。
2. 简单分为三个阶段：
	- 标记阶段：和标记清除一样，从根节点标记所有可达对象
	- 压缩阶段：将所有存活(标记)对象压缩(移动)到内存的一端
	- 清除阶段：清理边界外的所有空间(对象)
3. 标记-压缩算法的示意图：
![](http://p5ki4lhmo.bkt.clouddn.com/00060JVM%E5%AD%A6%E4%B9%A03-05.jpg)

---
## 4.复制算法及整合使用
**1)复制算法简介：**
1. 与标记-清除算法相比，复制算法是一个相对高效的回收算法
2. 不适用于存活对象多的场合（老年代）
3. 基本思想：
将原有的内存空间分为两块，每次只使用其中一块。
垃圾回收时将正在使用的内存块的存活对象复制到另一块未使用的内存块中。
清空当前正在使用的内存块中的所有对象，并交换两个内存块的角色，完成垃圾回收。
4. 复制算法的示意图：
![](http://p5ki4lhmo.bkt.clouddn.com/00060JVM%E5%AD%A6%E4%B9%A03-06.jpg)
5. 复制算法最大的问题：浪费空间

**2)复制算法整合标记清理思想：**
1. 示意图：
![](http://p5ki4lhmo.bkt.clouddn.com/00060JVM%E5%AD%A6%E4%B9%A03-07.jpg)
2. 说明：
	- 复制算法适用于年轻代(新生代)
	- 大对象直接进入老年代(老年代为年轻代做担保)
	- 多次GC未被清除的对象自动进入老年代
	- 复制其余对象到新的内存空间，清空原来的空间
3. 结合`-XX:+PrintGCDetails`日志分析：
![](http://p5ki4lhmo.bkt.clouddn.com/00060JVM%E5%AD%A6%E4%B9%A03-08.jpg)
	- 上面的三个内存块分别代表的是新生代的：eden,from,to区域
	- 新生代可用空间(第一行)=eden+复制区的其中一块内存(from/to)
	- 新生代可用空间一般比分配的空间小一些：from/to中有一块不可用
	((28d80000-28e80000)/1024>13824k)

**3)分代思想：**
1. 依据对象的存活时间分代，短命对象归为新生代，长命对象归为老年代。
2. 不同的代使用不同的算法：
	- 新生代：对象存活时间短，使用复制算法
	- 老年代：大量对象存活，适合标记-清理算法或者标记-整理算法
3. 注意：
所有的算法都需要识别一个垃圾对象，因此需要给出一个可触及性(可达性)的定义。

---
## 5.可触及性（可达性）



---