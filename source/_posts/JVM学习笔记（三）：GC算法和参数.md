---
title: JVM学习笔记（三）：GC算法，垃圾收集器种类及GC参数
date: 2018-5-9 18:26:56 
tags: JVM
categories: Java基础

---
## 0.学习准备
1. 基础落下了很多了，是时候啃一波JVM了
感觉很深奥，就先从视频看起，以后再看书补充啦
2. 参考资料
参考书籍《深入理解Java虚拟机》
第三章：垃圾收集器与内存分配策略
参考视频《深入理解JVM》(目前学习)
3. 简单目录：
	- GC简介
	- GC算法
		- 引用计数法
		- 标记清除算法
		- 标记压缩算法(标记整理)
		- 复制算法(新生代整合)
		- 分代思想
	- 可触及性(可达性)
	- Stop-The-World
	- 串行收集器
	- 并行收集器
	- CMS收集器
	- Tomcat演示

---
## 1.GC的概念
1. GC:Garbage Collection，垃圾收集
C语言是程序员自己申请和释放(管理)空间，Java中则是虚拟机来实现
(垃圾是指程序运行过程中产生的一些无用的对象，这些对象仍然占据了一定的内存空间，无用的对象需要及时回收以确保程序有足够的空间)
2. Java中，GC的对象是堆空间和永久区(受GC管理)。
JVM中有单独一个线程根据特定的算法来监控，扫描，释放无用的对象。
最主要的目的是为了防止程序员的操作而导致的内存泄露。
3. GC的思想最早出现在1960年时的List语言。
4. GC如何去管理内存空间--**GC算法**

---
## 2.引用计数法
**1)引用计数法简介：**
1. 老牌的垃圾回收算法：
给对象添加一个计数器，非0可用，0不可用。(差不多就是这种原理)
2. 通过引用计算来进行垃圾回收。
实现简单，判定效率也高，大部分情况下是一种不错的算法。
(不过在JVM中不常用)
3. 在以下技术中都有应用案例：
	- 微软的COM
	- ActionScript3的FlashPlayer
	- Python

**2)引用计数法的执行过程：**
1. 对于一个对象A，只要有任何一个对象去引用了A，则A的引用计数器就会加1，引用失效时A的引用数器就会减1，只要一个对象的程序计数器为0则该对象就不可用了(死了)。
2. 引用计数法的简单回收过程：(虚线代表引用失效)
![](http://p5ki4lhmo.bkt.clouddn.com/00060JVM%E5%AD%A6%E4%B9%A03-01.jpg)

**3)引用计数法的问题：**
1. 引用计数法的问题：
	- 引用和区引用都伴随着加减，影响性能
	- 很难处理循环引用
2. 循环引用的简单示意图：
![](http://p5ki4lhmo.bkt.clouddn.com/00060JVM%E5%AD%A6%E4%B9%A03-02.jpg)
3. 使用引用计数法处理循环引用的过程：
![](http://p5ki4lhmo.bkt.clouddn.com/00060JVM%E5%AD%A6%E4%B9%A03-03.jpg)
三个循环引用的对象对根对象来说不可达（应该被回收），但是因为每个对象的引用计数器都是1，所以都不会被回收。

---
## 3.标记-清除算法与标记-压缩算法
**1)标记清除算法：**
1. 标记清除算法是现代垃圾回收算法的思想基础。
分为两阶段：标记阶段和清除阶段。
2. 一种可行的实现：
	- 标记阶段：从根节点开始标记所以从根节点开始的可达对象。未被标记的对象则视为垃圾对象。
	- 清除阶段：清除所有的未被标记的对象。
3. 标记清除算法的示意图：
![](http://p5ki4lhmo.bkt.clouddn.com/00060JVM%E5%AD%A6%E4%B9%A03-04.jpg)
4. 标记-清除算法的不足之处：
	- 效率问题：标记和清除过程的效率都不高
	- 空间问题：清除之后产生大量不连续的内存碎片

**2)标记压缩算法(标记整理算法)：**
1. 标记压缩算法适用于存活对象较多的场合，如老年代。
是对标记清除算法的优化。
2. 简单分为三个阶段：
	- 标记阶段：和标记清除一样，从根节点标记所有可达对象
	- 压缩阶段：将所有存活(标记)对象压缩(移动)到内存的一端
	- 清除阶段：清理边界外的所有空间(对象)
3. 标记-压缩算法的示意图：
![](http://p5ki4lhmo.bkt.clouddn.com/00060JVM%E5%AD%A6%E4%B9%A03-05.jpg)

---
## 4.复制算法及整合使用
**1)复制算法简介：**
1. 与标记-清除算法相比，复制算法是一个相对高效的回收算法
2. 不适用于存活对象多的场合（老年代）
3. 基本思想：
将原有的内存空间分为两块，每次只使用其中一块。
垃圾回收时将正在使用的内存块的存活对象复制到另一块未使用的内存块中。
清空当前正在使用的内存块中的所有对象，并交换两个内存块的角色，完成垃圾回收。
4. 复制算法的示意图：
![](http://p5ki4lhmo.bkt.clouddn.com/00060JVM%E5%AD%A6%E4%B9%A03-06.jpg)
5. 复制算法最大的问题：浪费空间

**2)复制算法整合标记清理思想：**
1. 示意图：
![](http://p5ki4lhmo.bkt.clouddn.com/00060JVM%E5%AD%A6%E4%B9%A03-07.jpg)
2. 说明：
	- 复制算法适用于年轻代(新生代)
	- 大对象直接进入老年代(老年代为年轻代做担保)
	- 多次GC未被清除的对象自动进入老年代
	- 复制其余对象到新的内存空间，清空原来的空间
3. 结合`-XX:+PrintGCDetails`日志分析：
![](http://p5ki4lhmo.bkt.clouddn.com/00060JVM%E5%AD%A6%E4%B9%A03-08.jpg)
	- 上面的三个内存块分别代表的是新生代的：eden,from,to区域
	- 新生代可用空间(第一行)=eden+复制区的其中一块内存(from/to)
	- 新生代可用空间一般比分配的空间小一些：from/to中有一块不可用
	((28d80000-28e80000)/1024>13824k)

**3)分代思想：**
1. 依据对象的存活时间分代，短命对象归为新生代，长命对象归为老年代(15岁)。
2. 不同的代使用不同的算法：
	- 新生代：对象存活时间短，使用复制算法(Minor GC)
	- 老年代：大量对象存活，适合标记-清理算法或者标记-整理算法(Full GC)
3. 堆的构成如下：
![](http://p5ki4lhmo.bkt.clouddn.com/00060JVM%E5%AD%A6%E4%B9%A03-15.jpg)
4. 注意：
所有的算法都需要识别一个垃圾对象，因此需要给出一个可触及性(可达性)的定义。

---
## 5.可触及性（可达性）
**1)一些概念：**
1. 可触及的：
	- 从根对象可以触及到这个对象(到达这个对象)
2. 可复活的：
	- 一旦引用被释放，就是可复活状态
	- 在finalize()中可能复活该对象(GC前会调用finalize()方法)
	- finalize()方法只会调用一次
3. 不可触及的：
	- finalize()之后可能会进入不可触及的状态
	- 不可触及的对象不能复活
	- 可以被回收

**2)代码示例：**
1. 类的代码如下：
![](http://p5ki4lhmo.bkt.clouddn.com/00060JVM%E5%AD%A6%E4%B9%A03-09.jpg)
2. 测试代码如下：
![](http://p5ki4lhmo.bkt.clouddn.com/00060JVM%E5%AD%A6%E4%B9%A03-11.jpg)
3. 测试结果：
![](http://p5ki4lhmo.bkt.clouddn.com/00060JVM%E5%AD%A6%E4%B9%A03-10.jpg)
4. 结果分析：
类实现了finalize方法，使用一个自引用进行复活。
第一次GC前调用了finalize方法复活了，没有被回收。
第二次GC没有调用finalize方法，对象被回收。
5. 如果在不在第二次赋值为null（finalize结束后一直不释放引用），那么这个对象永远不会被回收。

**3)finalize方法的缺陷：**
1. 经验告诉我们：
	- 避免使用finalize()，操作不慎可能导致错误。
2. 主要的缺陷有：
	- 优先级低，何时被调用不确(原因就是GC何时调用不确定)
	- 何时进行GC也不确定
3. 改进：使用try-catch-finally来替代
在finally中释放资源

**4)根对象：**
- 栈中的引用对象
- 方法区静态成员或者常量引用的对象（全局变量）
- JNI本地方法栈中的对象

---
## 6.Stop-The-World
**1)Stop-The-World简介：**
1. Java中的一种全局暂停的现象：
全局停顿，所有的Java代码停止运行，本地方法可以运行，但是不能和JVM交互。
2. 引起该现象的原因：
	- GC(大部分情况，系统判断产生)
	- 死锁
	- Dump线程(操作失误)
	- Dump堆(操作失误)
3. 为什么会全局停顿：
在清理垃圾时又有新的垃圾产生，只有将程序停止，才能真正的打扫干净。
GC线程清理垃圾的时候，将所有的线程停止，保证没有新的垃圾产生(可以比较顺利地进行)
新生代比较快，而老年代一次GC的时间很长，会导致一些问题。
4. 危害：
	- 长时间服务停止，没有响应(老年代GC)
	- 遇到HA(高可用)系统，可能会引起主从切换，严重危害生产环境。

**2)全局停顿测试：(了解即可)**
1. 测试线程：每0.1秒打印一条信息
![](http://p5ki4lhmo.bkt.clouddn.com/00060JVM%E5%AD%A6%E4%B9%A03-12.jpg)
2. 测试代码与测试参数：
![](http://p5ki4lhmo.bkt.clouddn.com/00060JVM%E5%AD%A6%E4%B9%A03-13.jpg)
3. GC日志分析：
![](http://p5ki4lhmo.bkt.clouddn.com/00060JVM%E5%AD%A6%E4%B9%A03-14.jpg)
从3153开始分别暂停了0.28秒和0.71秒。
可以在右侧的GC日志中找到相对应的GC(根据GC处理的真实时间)。
共三次时间较长的GC:0.28秒，0.28秒和0.43秒（第二次和第三次中间没有间隔，所以未输出任何信息）

---
## 7.串型垃圾收集器(回收器)
**1)串型收集器简介：**
- 最古老，最稳定
- 效率高
- 可能会产生较长的停顿时间
- 如何使用：`-XX:+UseSerialGC`
	- 新生代/老年代都会使用串行回收
	- 新生代使用复制算法(Serial串行收集器)
	- 老年代使用标记-压缩(整理)算法(Serial Old串行收集器)

**2)示意图与日志示例：**
1. 示意图：简单的流程
![](http://p5ki4lhmo.bkt.clouddn.com/00060JVM%E5%AD%A6%E4%B9%A03-16.jpg)
2. 示例日志输出：
![](http://p5ki4lhmo.bkt.clouddn.com/00060JVM%E5%AD%A6%E4%B9%A03-17.jpg)
3. 串行回收器线程运行时应用程序线程暂停。
4. 实际是Serial+Serial Old收集器

---
## 8.并行垃圾收集器(回收器)
**1)ParNew收集器：**
1. 是Serial(新生代收集器)的并行版本。
2. 参数：`-XX:+UseParNewGC`
	- 新生代并行(ParNew)，复制算法
	- 老年代串行(Serial Old)，标记-压缩(整理)算法
3. ParNew是多线程的收集器，需要多核支持。
4. 限制线程数量的参数：`-XX:+ParallelGCThreads`
5. ParNew示意图：
![](http://p5ki4lhmo.bkt.clouddn.com/00060JVM%E5%AD%A6%E4%B9%A03-18.jpg)
日志输出示例：
![](http://p5ki4lhmo.bkt.clouddn.com/00060JVM%E5%AD%A6%E4%B9%A03-19.jpg)
6. 并行收集器并不是在所有的情况下都比串行收集器快。

**2)Parallel收集器：**
1. 分为两个：
	- Parllel Scavenge：新生代并行收集器
	- Parllel Old：老年代并行收集器
2. 类似ParNew，也是一个并行收集器:
	- 新生代复制算法
	- 老年代标记压缩算法
3. Parllel Scavenge和ParNew差不多，但是无法和CMS收集器(后面介绍)配合使用。
4. 和一般的收集器不同，它更加关注吞吐量(其他的则是关注如何缩短等待时间)
5. 参数使用：
`-XX:+UseParllelGC`：使用Parllel Scavenge+老年代串行收集器
`+XX:UseParllelOldGC`：使用Parllel Scavenge+Parllel Old
6. 示意图：
![](http://p5ki4lhmo.bkt.clouddn.com/00060JVM%E5%AD%A6%E4%B9%A03-20.jpg)
日志输出示例：
![](http://p5ki4lhmo.bkt.clouddn.com/00060JVM%E5%AD%A6%E4%B9%A03-21.jpg)

**3)并行回收器的相关设置参数：**
1. 停顿时间参数：`-XX:MaxGCPauseMills`
	- 最大停顿时间，单位毫秒
	- GC尽量保证回收时间不超过这个值
2. 吞吐量参数：`-XX:GCTimeRatio`
	- 0~100取值范围
	- 垃圾收集总时间占程序运行CPU总时间的比
	- 默认为99，即允许1%的时间做GC
	- 时间越短，每次需要回收的对象越多，吞吐量越大，GC停顿时间越长。
3. 这两个参数是矛盾的，不能同时设置(停顿时间和吞吐量)
这两项不能同时调优

---
## 9.CMS收集器


---
## 10.G1收集器


---
